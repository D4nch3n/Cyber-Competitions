# PwnyOS Challenges (Kernel)

This was a series of blackbox kernel exploration/exploitation challenges during UIUCTF last week. Gotta say, huge kudos to @Ravi for developing an entire freaking kernel for a ctf! While I didn't solve many of them during the ctf, I think this will still be an interesting topic to write about, especially given some of the unintended stuff I've seen.

I'll be writing up the challenges in sequential order, but note that the only challenges I've solved were How to Get Started, Kernel::Time_To_Start, Whats_a_syscall?, Small Oops, and Freaky_File_Descriptors.

Without further ado...

## How to Get Started

![](https://i.imgur.com/0VU3jwa.png)

This is the "challenge" that gave competitors everything they needed. We were given access to pwnyOS through VNC credentials, and in the github repository, we were given two guides: a guide on the basic features of pwnyOS, and a guide on what syscalls that pwnyOS supports.

I won't go through the entire guides in this writeup, rather I will include bits and pieces of them as they become relevant.

We could find the flag by just going to the github repo, and viewing instructions on how to connect to our VM:

![](https://i.imgur.com/faCCbuA.png)

Easy flag :P

## Kernel::Time_To_Start (100 pts)

![](https://i.imgur.com/h0HxhHh.png)

Looks like our first task is to login. When we connect through VNC, we are greeted with this login panel:

![](https://i.imgur.com/Eh8WQ8r.png)

We know that the username is sandb0x, and that the password is four lowercase letters that begins with the letter 'p'. 

One way to solve this is to see what four letter word that begins with a 'p' gets referenced. Since this OS's name is called pwnyOS, a good guess for the password is 'pwny'. (That's how I solved this challenge).

However, what if you can't guess the password? Recall that the challenge description implies that knowing the first part of the password may help determine the rest. What happens if we try to login with the username `sandb0x`, and the password `p`?

![](https://i.imgur.com/WfA56Dz.png)

Not surprisingly, the password is incorrect. However, we notice that it takes around 0.5 seconds for the "Incorrect Password!" to pop up. On the contrary, if we attempted to login with the password `q`, we get the prompt displayed right away.

What we have here now is a time-based side channel attack: For each additional letter after p, if that letter is correct and in the correct position, we know that it'll take slightly longer for the "Incorrect Password!" prompt to pop that. After we get enough letters, when we login with the password of `pwny`, we find that we are able to successfully login.

![](https://i.imgur.com/8yvokVr.png)

This challenge is easy if you're able to guess the password, but it could get frustrating if you decided to manually carry out the side channel attack.

## Whats_a_syscall?

![](https://i.imgur.com/lnx3vwY.png)

For this challenge, we need to perform the SANDBOX_SPECIAL syscall. As mentioned in the prompt after getting the flag for Time_To_Start, we've logged in...into a sandbox program called binexec. Fortunately, though, this program is able to run any x86 shellcode that we give them, which should make performing the SANDBOX_SPECIAL syscall fairly easy.

What are syscalls? In an operating system, there are various modes/rings of execution. There's execution in user mode (Ring 3), which doesn't have many privileges: Code executed in user mode includes processes from users on the system, including admin users. Code executed in user-mode cannot open, read, or write files on their own, nor can they modify memory outside of their own process space. There's also execution in kernel mode (Ring 0), which has the "most" amount of privileges (this isn't entirely accurate, but the reason is beyond the scope of this writeup). Code executed in kernel-mode are indeed able to open/read/write to files, execute/modify the memory of other processes (and the kernel itself), and do other privileged stuff!

However, you may be wondering why as a user you are able to create files onto the filesystem, if everything we do is in user mode. This is where syscalls come in. Syscalls allows code that's executed in user-mode to make specific requests to the kernel, asking the kernel to do something specific. There's syscalls that allows user-mode programs to read and write to files, execute other programs, etc. in a controlled manner (so that no user can just edit whatever file they please)

Let's look at how syscalls are invoked in pwnyOS, by looking at the syscall guide:

![](https://i.imgur.com/wgHXSg7.png)
![](https://i.imgur.com/FntqtEo.png)

Aside from the different syscall numbers, this is honestly pretty similar to how syscalls are implemented in i386 Linux. However, we want to use the SANDBOX_SPECIAL syscall, which has a syscall number of 14.

Therefore, we just need to set the eax register to 14 (0xe in hex), and then execute the int 0x80 instruction (which performs a syscall) with the following assembly:

```
mov eax, 0xe
int 0x80
```

We then use an assembler to assemble this, which we can get from https://defuse.ca/online-x86-assembler.htm, into the following bytes:

`B8 0E 00 00 00 CD 80`

We go to binexec, and enter these bytes:

![](https://i.imgur.com/4je82rL.png)

Then, we can enter the word `done`, and escape the sandbox!

![](https://i.imgur.com/KwVdp4f.png)

Once we press enter again, we see that we got a low privilege shell on pwnyOS:

![](https://i.imgur.com/HqKwDUT.png)

## KASLR_LEAK

![](https://i.imgur.com/yJbmmFP.png)

This challenge was a weird (and, imo, pretty vague) one, where we need to figure out where kASLR is being leaked. I was unable to solve this during the CTF, even though the solution ended up being relatively simple (but rather arbitrary).

We now have a rash shell on this system, let's see what we can do:

Let's first go to /bin to see what programs we can run:

![](https://i.imgur.com/6U9SyQg.png)

So the only programs we can run is rash, lsproc, and binexec. However, if we take a look at the guide to pwnyOS, we see that rash offers some builtins as well:

![](https://i.imgur.com/cJsLVFz.png)

We also see in the guide that pwnyOS uses a read-only file system:

![](https://i.imgur.com/oOcapmZ.png)

Normally when we try to look for kernel pointers, we'd look for them in dmesg, `/proc/kallsyms`, etc. However, the only file in /proc in this filesystem is `/proc/all`. When we try to view the file, we see the following:

![](https://i.imgur.com/WzAJcVe.png)

Not too useful. Since pwnyOS is not giving its secrets very easily, we should probably look somewhere else. Let's go back to binexec to see what else we could do, since binexec is the only location where we can execute stuff of our choice.

### Intended solution:

In various versions of x86, users shouldn't expect their userland registers to be saved before and after a syscall. This is because the kernel may utilize registers in various ways while the syscall is being performed (for example, the kernel sets the return value in eax)

Let's see how the general purpose registers in x86 are modified in pwnyOS! (so eax, ebx, ecx, and edx). We'll use some code that performs a sys_open syscall (so syscall number 2) with the first parameter pointing to an invalid userland address (we don't want to actually open a file, not yet), as follows:

```
mov eax, 2
mov ebx, 0x08040000
mov ecx, 0x42424242
mov edx, 0x43434343
int 0x80
```

How do we know that 0x8040000 is a valid userland address? According to the pwnyOS guide:

![](https://i.imgur.com/RXj3ndW.png)

Since when the executable is executed, it gets loaded at address 0x8040000, we can be confident that that address is valid. When we assemble this assembly code, we get the following bytes:

`B8 02 00 00 00 BB 00 00 04 08 B9 42 42 42 42 BA 43 43 43 43 CD 80`

When we enter the code into binexec, we get the following output:

![](https://i.imgur.com/Qn9wVb1.png)

Oooh it's pretty convenient that binexec actually tells us the register contents of the general purpose registers after each execution. Looking at the output, we see that eax got changed to -1 0xffffffff (which is expected, since we didn't open a valid file), and ebx and edx are unchanged. However, ecx got changed to an interesting value, which is 0x400000

After doing a few more syscalls in binexec, we found that ecx repeatedly gets changed to 0x400000, which is suspect. Recall that the hint in the challenge description said to look for an address that is 4 MB aligned: since 4 MB is equal to 0x400000 bytes, this address fits that description. Therefore, to get the flag, all we need to do is to invoke the SANDBOX_SPECIAL syscall, with 0x400000 as the parameter:

```
mov eax, 0xe
mov ebx, 0x400000
int 0x80
```

When assembled, we get the following bytes:

`b8 0e 00 00 00 bb 00 00 40 00 cd 80`

And when we put it into binexec, we get the flag:

![](https://i.imgur.com/kTYbY8r.png)

Personally I'm not a huge fan of this challenge, as there's nothing that indicates this address is actually randomized with KASLR (heck this value stays the same even upon a reboot, so are the addresses really random?) I wish there were some way that made it more obvious that this was a kernel base address (other than it being 4 MB aligned), and that we can see the randomized kernel slides every time we reboot the machine.

## Kernel_Memory_Leak

![](https://i.imgur.com/X6GpSYQ.png)

This was a really tricky challenge (it had the least amount of solves at the end, and nope I'm not counting the root challenge as that challenge had a dependency), tricky enough that even after @ravi's hints after the CTF I still wasn't able to solve this. Some ideas I've explored is to perform the alert/write syscall with a memory address at the boundary of our memory page (since if I were to directly pass an address outside the memory page, the kernel will complain about it not being a valid user pointer). However, this only gave me a page fault kernel panic:

![](https://i.imgur.com/269Sq9y.png)

After exhausting all my options, I'll leave this section blank for now until I manage to figure out the solution.


## Freaky_File_Descriptor (and small oops)

![](https://i.imgur.com/nfeBNR8.png)

This challenge was a pretty straightforward one, as long as you're able to find the unintended way (which is what we did.) This writeup for now will only go over the unintended way, at least until I figure out what the intended way is :P

Anyways, for this challenge, we need to somehow find a way to read past the end of `/sandb0x/freaky_fds.txt` to get a flag. If we try to do that normally (by just cd'ing into the /sandb0x directory, and running `cat freaky_fds.txt`), we see that the flag seems to be cut off:

![](https://i.imgur.com/QfWAkb6.png)

At this point, instead of doing rational things such as exploring how this operating system handles file descriptors and file reading, we decided to just manually fuzz the filesystem for bugs. 

Although we don't know what type of file system pwnyOS uses (other than it's read-only), different file systems have certain similarities with each other. For example, files and directories are stored as directory entries in a filesystem, and they contain certain flags that tell the kernel whether a directory entry is a directory or a file. Also, the data stored in a directory entry is pretty similar for both files and directories (at least for FAT/NTFS filesystems), except instead of the contents of a file, the data stored in directories are references to other directory entries that are inside this directory.

As anyone who's taken an operating systems course may know, parsing file systems is a complicated process. Therefore, we may try a few things with this filesystem on pwnyOS that would normally fail on linux/windows.

What if pwnyOS didn't check to see if a directory entry pointed to a file or a directory? Therefore, we could treat a directory as a file (and for example, print it out), and we could treat a file as a directory (and for example, cd into it.) Since `freaky_fds.txt` seems to be a file, what happens if we treat it as a directory, and cd into it?

![](https://i.imgur.com/xAwob44.png)

Looks like we're able to go into that "directory" just fine. Now, what happens if we run `ls` in there? Remember that since the contents of a directory directory entry just contains references to the directory entries that are inside this directory, and so the `ls` command normally prints out all the directory entries that are present.

![](https://i.imgur.com/pXOAJN8.png)

....oops! Since this is a file and not a directory, the `ls` just ended up printing out the entire file (past the end), and gave us the flag!

Since this felt way too easy for a 400 pt problem, we submitted this solution to modmail, and got 200 pts for the Small Oops challenge (finding a bug that allows you to complete a challenge without using a kernel exploit)

![](https://i.imgur.com/rpeAuho.png)

Thanks, Ravi! :D

## Crazy_Caches

![](https://i.imgur.com/cqCENp9.png)
![](https://i.imgur.com/uNm8sEc.png)

Now we're going in deep into the kernel for privilege escalation bugs! This was a pretty tricky challenge that we weren't able to solve before the CTF ended, but eventually figured it out after seeing some hints be put out after the end of the CTF.

When we run `lsproc`, we do see that there's a crazy_caches process running with an uid and a pid of 1:

![](https://i.imgur.com/43bSiCg.png)

We also see that our rash process is running with a uid and pid of 2.

Let's take a look at the pseudocode for crazy_caches:

```
int main ():
    byte *mmap_addr = syscall_mmap();
    if (!mmap_addr):
        print ("[crazy_caches] Couldn't mmap!")
        return -1

    while True:
        for x = 0; x < 0x1000; x++:
            mmap_addr[x] = 0xc3

        while ((uint32_t *)mmap_addr)[0] != 0xdeadc0de:
            wait()

        call((method)((byte *)mmap_addr + 0x400))
```

Basically this program mmaps a 4 MB page (contiguous chunk) of memory (since from the kaslr challenge the base address is 4 MB aligned), and goes into an infinite while loop where it sets the first four kilobytes of that memory to 0xc3 (opcode for a ret instruction), goes to another while loop where it checks if the first 4 bytes of the mmap'd region is equal to 0xdeadc0de. If it is, then it breaks out of the loop, and transfers execution of offset 0x400 from the mmap'd region of memory.

We can infer that we need to somehow get this process to execute stuff that we control, but how can we do that?

First, we need to know how mmap and memory pages work in pwnyOS. The following is the description of the mmap syscall:

![](https://i.imgur.com/wwT79Uw.png)

Basically, in pwnyOS (and in other OS's), mmap directly requests a page of memory from the kernel. In this OS, each process can only mmap once, and the mmaped region is 4 MB in size and is located at 0x0d048000 in the user process. This region has read/write/execute permissions, and gets unmapped when the process exits.

Next, let's see how the kernel manages memory pages that are requested by each process. In older kernels (without the translation lookaside buffer), when a program requests a memory page from a kernel, the kernel will set aside a page of physical memory to the process, and sets up a series of page tables so that the returned virtual address  (the address of the page in the process) to the memory page can be translated into the physical address (the address of the of the page in the hardware) of the memory page. When the program then attempts to read/write/execute stuff inside the mmap'd page at a virtual address, the kernel will then traverse the page tables that corresponds to this virtual address (also known as a page walk) to get the corresponding physical address, and then reads/writes/execute stuff from that location. All of this takes place in the memory management unit of the kernel (MMU)

Performing page walks to locate the physical address that corresponds to a virtual address is very time consuming, however, since the kernel will have to do this each time the program accesses that page of memory. Therefore, in newer OS's (and in pwnyOS), there exists a structure called the translation lookaside buffer in the memory management unit, which caches the virtual address to physical address mapping. When a program accesses a new page of memory for the first time, it will first check the translation lookaside buffer to see if the corresponding physical address exists. If it doesn't (which it shouldn't, since the program's accessing it for the first time), then the kernel will do the usual time-consuming page walk to locate the physical address, and before returning to user-mode, saves the virtual address to physical address mapping into the translation lookaside buffer. The next time the program accesses this particular page, the kernel will be able to just view what is stored inside the translation lookaside buffer, and return the corresponding physical address (without doing the time-consuming page walk).

If we look back at the problem text, we see something interesting:

```
Since the mmap syscall isn't supported for sandboxed users, 
do I really need to update that page directory EVERY time I 
context switch? Sounds like a lot of extra work...
```

We don't have the ability to run the mmap system call as we're still a sandbox user. However, the second sentence implies that the kernel author likely decided to not update/flush the translation lookaside buffer upon a context switch, which does seem problematic.

First, what's a context switch? We tend to believe that the kernel can run processes in parallel (and in multi-core systems, this is true to a degree), however in actuality, the kernel rapidly switches execution between processes to give the illusion of parallel execution. One way the kernel is able to switch execution is to issue an interrupt to a process: That process stops executing for a few clock cycles and another processes resumes execution, until the kernel sends another interrupt. Another way the kernel is able to switch execution is when a process performs a system call; since system calls tend to take some time (e.g. read/write syscalls), the kernel may allow another process to execute stuff while it's processing the system call.

Each time the kernel switches execution of a process it performs a context switch, which includes saving the registers of the process it's switching from, and restoring the registers of the process it's switching to. In modern systems with memory caching, a context switch also flushes caches such as the translation lookaside buffer as well.

Now, why do we need to flush the translation lookaside buffer when performing a context switch? Imagine, for example we have two processes: Process A and process B. Both process have requested a 4 MB page through mmap, process B is currently executing, and process B has accessed the mmap'd page (so the virtual address to process B's physical address mapping exists in the translation lookaside buffer). Now, suppose the kernel issues an interrupt to process B so that process A can continue executing. If the translation lookaside buffer is flushed during the context switch, when process A tries to access its mmap'd page, the translation lookaside buffer is empty, so the kernel will do the usual page walk to find the physical address that corresponds to process A's virtual address of the mmap'd page. A little slow, but at least both processes are accessing their own page of memory.

Now, let's suppose the translation lookaside buffer isn't flushed during a context switch. Then, when the kernel transfers execution from process A to process B, the mapping of virtual address to process B's physical address still remains inside the translation lookaside buffer. Recall in pwnyOS, mmap'd memory is always located at the same virtual address. Then, when process A tries to access that mmaped memory page, the kernel will see that a mapping exists for that virtual address in the translation lookaside buffer, and will use that mapping instead of doing the page walk, even though that mapping points to process B's physical address!!! Therefore, the processes are no longer isolated from each other, as process A can access and modify process B's memory (and vice versa, since that memory mapping doesn't get flushed).

Now that we know the issue of not flushing the translation lookaside buffer, let's discuss how we can leverage this vulnerability. We can apply our scenario to the process A/B hypothetical, where the crazy_caches process is process A, and our binexec process is process B (recall that we still need to use binexec to execute our own shellcode). Therefore, exploiting this vulnerability is simple, right? We just modify binexec's mmap'd memory so that the first 4 bytes are 0xdeadc0de, and the bytes at 0x0d048000 + 0x400 to be our shellcode. For our shellcode, we just need to use the remote_setuser syscall:

![](https://i.imgur.com/wBmqcfC.png)

so that when the crazy_caches process executes our shellcode, it will be able to elevate the privileges of our rash shell, which has a pid of 2. Simple enough, right?

There's one issue though: the sandb0x user doesn't have permission to use the mmap syscall:

![](https://i.imgur.com/7awOvDj.png)

Therefore, we thought we don't have access to the memory page located at 0x0d048000, and so can't mess with the translation lookaside buffer. If we try to write to that address, since that memory region isn't given to us by the kernel yet, we would end up in a segmentation fault. Rip our goals and dreams....

After the ctf ended, we got word that other competitors were able to successfully write to that memory region, without causing a segfault (which made me pretty indignant lol). How was that possible when they weren't allowed to use mmap as the sandb0x user?!

Turns out, even when checking addresses that aren't valid to the user process yet, the kernel will still defer to the mapping that's stored in the translation lookaside buffer. Since the virtual address to the crazy_cache's process's physical address mapping does exist inside the translation lookaside buffer (as the crazy_caches process accessed that mmap'd region when it was filling the memory region with 0xc3), when we try to access that virtual address, we will end up accessing crazy_cache's physical address of the mmap'd region, and so we could indeed modify crazy_cache's mmap'd memory page. (god damnit this is why you test your ideas instead of making assumptions on why it won't work aaaaaaaaaaaaaaaaa)

### The exploit:

Anyways, now that we know that we can write to crazy_cache's mmap'd memory page, our exploit is now as follows:

We want crazy_cache to execute this shellcode:

```
mov ebx, 0x2
mov eax, 0xc
int 0x80
```

When assembled, this assembly code translates to this:

```
BB 02 00 00 00 B8 0C 00 00 00 CD 80
```

This shellcode basically performs the remote_setuser syscall to set the privilege of the process with a pid of 2 (our rash shell) to the privilege of the crazy_caches process).

We need to get this data into memory, however. We also need to remember to set the first 4 bytes of the mmap'd memory page to 0xdeadc0de. To do that, we could use a series of mov's:

```
mov eax, 0xd04800
mov dword ptr [eax], 0xdeadc0de ; setting the deadc0de string
add eax, 0x400
mov dword ptr [eax], 0x000002bb ; writing the shellcode (note endianness)
mov dword ptr [eax+0x4], 0x000cb800
mov dword ptr [eax+0x8], 0x80cd0000
```

When we assemble this, we get:

```
B8 00 80 04 0d C7 00 DE C0 AD DE 05 00 04 00 00 C7 00 BB 02 00 00 C7 40 04 00 B8 0C 00 C7 40 08 00 00 CD 80
```

Let's put this into binexec and see what happens:

![](https://i.imgur.com/bWwOcmA.png)

Looks like we got the flag! And when we exit binexec to view the permissions of our rash process:

![](https://i.imgur.com/kF5bFQK.png)

We are no longer the sandb0x user, and our UID is now 1!

## Kernel::Run_it_as_Root

![](https://i.imgur.com/X95Dpen.png)

Now that we have fully escaped the sandbox, it's time for the last leg of our journey: Rooting the box.

We know that the OS doesn't perform translation lookaside buffer flushing very well, and so if there's a process running as the root user, we could try to use the same exploit to become root. However, when we run lsproc, we see that that's not the case:

![](https://i.imgur.com/7lS9Jf3.png)

We do remember, however, that there's a /user directory that we weren't able to access before as the sandb0x user. Now that we are no longer the sandb0x user, let's see what's inside:

![](https://i.imgur.com/O1JfDvC.png)

Looks like there's a empty file called .gitignore, which is weird (what use could an empty file give to us?)

If we take another look back at the challenge description, we see that it mentions that the kernel page allocator doesn't initialize its memory before giving the page to the user. This indicates that the memory page given by the kernel could contain data from previous usage of the same memory page.

How could this be beneficial to us? Well, when we execute a program (at least in pwnyOS), the kernel allocates a page of memory to us, copies the contents of the program to the page, initialize the registers, sets the instruction pointer to the entrypoint of the program, and begins execution. Now, when we're executing actual ELF's, the uninitialized memory issue won't have much impact, as the leftover memory will be overwritten by the contents of the program we're executing. However, interesting things happen if we try to execute smaller non-executable files (such as the empty .gitignore file); if there's leftover memory from the execution of another program, then executing the empty .gitignore file will execute that program instead!

The syscall guide entry for sys_exec also describes this well (key points highlighted in red):
![](https://i.imgur.com/CC5s8lO.png)



Let's see this quirky behavior in action! When we try to execute `/user/.gitignore`, we see that the execution fails:

![](https://i.imgur.com/yv8aIh6.png)

This fails because the kernel allocated a fresh new page for the .gitignore program, and since it's a page that hasn't been used before, there's nothing except 0's in the memory page. However, if we execute another rash shell, then exit that shell (remember that memory pages are only released when a process exits), when we try to execute `/user/.gitignore`, we get something interesting:

![](https://i.imgur.com/RKVkxvA.png)

We somehow managed to execute rash! This is because since the `.gitignore` file is empty, when the kernel attempts to execute the `.gitignore` program, it doesn't overwrite anything in the memory page. Since the memory page of the rash process was freed to the kernel, when we executed `.gitignore`, the kernel decided to give that memory page to the `.gitignore` "process". Since the memory page contents weren't initialized, the contents inside the `.gitignore` process's memory page were identical to the contents of rash, and so rash was executed. Weird!

How does this help get us to our goal though? Let's take a look at some unique aspects on how pwnyOS binaries work, in the getting started guide:

![](https://i.imgur.com/5ObrmVU.png)

Basically, pwnyOS implemented their own version of setuid programs, where the first byte of the ELF header determines what user id this program will run under. In this case, for example, we want to escalate to the root user (with user ID 0), so we need to somehow execute a program with 0x80 as the first byte to run a blocking program with the user ID of 0.

How can we do that? Even with the weird memory initialization issue, it doesn't seem to allow us to write that byte into an exeutable, as the file system is read only! However, remember that as a non-sandbox user, we can use the mmap syscall in binexec! This will let the kernel give us a page of uninitialized memory, which we can modify and place back into the kernel pool for it to be allocated later, when we run `.gitignore`!

One final note before we run the exploit: We don't really know how the kernel page allocation algorithm works. It could be that the kernel tries to give out the most recently used page of memory back, it could be that the kernel tries to give out the least recently used page of memory back, or it could be something else. One way to see what happens is by doing the following:

In a new session, execute rash, then binexec, then exit both of these processes (exit binexec first, then rash; the order matters here!):

![](https://i.imgur.com/Z9B4ulN.png)

Next, we'll try to execute `/user/.gitignore`, and see what gets executed. If rash ends up getting executed, we know that the kernel tries to give out the most recently used page of memory back, as rash was the last process we had exited (so it had the most recently freed page of memory). If binexec ends up getting executed, we know that the kernel tries to give out the least recently used page of memory back, as binexec was the process that exited first (so it had the least recently freed page of memory). Let's see what happens:

![](https://i.imgur.com/I83JyiX.png)

Looks like rash was executed, so we confirm that the kernel tries to give out the most recently used page of memory back to new processes. We now know enough to craft our exploit.

### Running the exploit

First, we'll run rash twice (Let's say the memory page for the first rash process is page A, and the memory page for the second rash process is page B), and exit both of them:

![](https://i.imgur.com/P8YWvQ0.png)

Since we exited both rash processes, both memory pages A and B have been freed by the kernel. Next, we'll execute binexec:

![](https://i.imgur.com/VwKrkvY.png)

Since memory page B was freed last, memory page B is now used by this binexec process. Next, we'll execute the mmap syscall by using the following shellcode:

```
mov eax, 0xd
int 0x80
```

This will cause the kernel to give us page A into our memory allocation. Since this was once used by the rash process, we'll add some additional shellcode to set the first byte of the mmap'd page to 0x80 (to make it setuid as root):

```
mov eax, 0xd048000
mov byte ptr [eax], 0x80
```

Therefore, our final shellcode is:

```
mov eax, 0xd
int 0x80
mov eax, 0xd048000
mov byte ptr [eax], 0x80
```

Which, when assembled, gives us this:

```
b8 0d 00 00 00 cd 80 b8 00 80 04 0d c6 00 80
```

Let's execute this in binexec:

![](https://i.imgur.com/ZojgjgX.png)

So far everything seems good. Now we exit the binexec process (which will free both memory page B and A back to the kernel.)

We have a slight dilemma here: What gets freed first? memory page B or memory page A? Unfortunately, there's no good way to know the answer for sure except to try both options. If memory page A got freed first, then after exiting binexec, we just need to run `/user/.gitignore` to get a root rash shell (since page A with contains our setuid modification will be returned to the `/user/.gitignore` process). However, if memory page B got freed first, then after exiting binexec, we need to run another rash shell first (so that memory page B, which doesn't contain our setuid modification, gets returned to the rash process) before we can run `/user/.gitignore` (which will be run under memory page A).

After trying both assumptions, we found out that memory page B got freed first, so we had to run rash once before we could run `/user/.gitignore`. However, once we get a shell, when we ran the whoami command, we see that we are now root!

![](https://i.imgur.com/b34xtK7.png)

Sweet! Now we can go to /root to view the flag!

![](https://i.imgur.com/Biqativ.png)

Whoops, not quite there yet! Looks like the flag is in the /prot directory instead (I'm assuming this was done to make sure we had code execution as root).

Anyways, we could go to /prot, and view the protected.txt file to get our flag!!!

![](https://i.imgur.com/cs4LOIm.png)

Definitely enjoyed this kernel exploitation challenge series indeed, and will be looking forward to pwnyOS's revenge! (Hopefully I'll be able to solve more before the end of the CTF haha) Thank you @ravi for writing this series, and to the sigpwny CTF team for hosting this brutally difficult CTF!



